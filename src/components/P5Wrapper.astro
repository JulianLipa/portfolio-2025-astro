---
import "./P5Wrapper.css";
interface Props {
  color?: string;
}
const { color = "#e6e6e6" } = Astro.props;
---

<div id="p5-canvas-container"></div>

<script>
  import p5 from "p5";

  const container = document.getElementById("p5-canvas-container");

  const sketch = (p: any) => {
    const boxes: Box[] = [];
    const gravity = 0.4;
    const bounce = 0.05;
    const labels = [
      "Ecommerce",
      "Desarrollo Web",
      "Diseño UX/UI",
      "Branding",
      "Concept art",
    ];

    let minX: number, maxX: number;
    const marginPercent = 0.05;

    p.setup = () => {
      const canvas = p.createCanvas(window.innerWidth, window.innerHeight);
      canvas.parent(container);
      p.rectMode(p.CENTER);
      p.textAlign(p.CENTER, p.CENTER);
      p.textSize(16);

      minX = p.width * marginPercent;
      maxX = p.width * (1 - marginPercent);

      /*
      x, y        → posición
      w, h        → tamaño
      vy          → velocidad vertical
      angle       → rotación visual
      text        → contenido
      */
     
      for (let i = 0; i < labels.length; i++) {
        boxes.push(
          new Box(
            p.random(minX, maxX),
            p.random(-300, -50),
            140,
            60,
            p.random(-p.PI / 12, p.PI / 12),
            labels[i]
          )
        );
      }
    };

    p.draw = () => {
      p.clear();
      for (const b of boxes) b.update();
      for (let i = 0; i < boxes.length; i++) {
        for (let j = i + 1; j < boxes.length; j++) {
          resolveCollision(boxes[i], boxes[j]);
        }
      }
      for (const b of boxes) b.show();
    };

    class Box {
      x: number;
      y: number;
      w: number;
      h: number;
      angle: number;
      text: string;
      vy: number;

      constructor(
        x: number,
        y: number,
        w: number,
        h: number,
        angle: number,
        text: string
      ) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.angle = angle;
        this.text = text;
        this.vy = 0;
      }

      update() {
        this.vy += gravity;
        this.y += this.vy;

        // Evitar que se salga de los márgenes horizontales
        if (this.x - this.w / 2 < minX) this.x = minX + this.w / 2;
        if (this.x + this.w / 2 > maxX) this.x = maxX - this.w / 2;

        if (this.y + this.h / 2 > p.height) {
          this.y = p.height - this.h / 2;
          this.vy *= -bounce;
          if (Math.abs(this.vy) < 0.1) this.vy = 0;
        }
      }

      show() {
        p.push();
        p.translate(this.x, this.y);
        p.rotate(this.angle);
        p.fill(255);
        p.stroke(0);
        p.rect(0, 0, this.w, this.h, 8);
        p.noStroke();
        p.fill(0);
        p.text(this.text, 0, 0);
        p.pop();
      }
    }

    function resolveCollision(a: Box, b: Box) {
      if (
        Math.abs(a.x - b.x) < (a.w + b.w) / 2 &&
        Math.abs(a.y - b.y) < (a.h + b.h) / 2
      ) {
        const overlapY = (a.h + b.h) / 2 - Math.abs(a.y - b.y);
        if (a.y < b.y) {
          a.y -= overlapY;
          a.vy *= -bounce;
        } else {
          b.y -= overlapY;
          b.vy *= -bounce;
        }
      }
    }

    p.windowResized = () => {
      p.resizeCanvas(window.innerWidth, window.innerHeight);
      minX = p.width * marginPercent;
      maxX = p.width * (1 - marginPercent);
    };
  };

  new p5(sketch);
</script>
